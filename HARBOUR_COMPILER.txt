HB_COMP_ERR_EXIT_IN_SEQUENCE

if( pLast->wSeqCounter != pFunc->wSeqCounter )
{
         /* Attempt to LOOP from BEGIN/END sequence
          * Current SEQUENCE counter is different then at the beginning of loop
          * Notice that LOOP is allowed in RECOVER code when there is no
          * ALWAYS block
          */
         hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "LOOP", NULL );
}


hberrors.h
==============================================================

#define HB_COMP_ERR_CHECKING_ARGS               21


src/compiler/hbgenerr.c
===============================================================

const char * const hb_comp_szErrors[] =
{
   "Statement not allowed outside of procedure or function",
   "Redefinition of procedure or function '%s'",
   "Duplicate variable declaration '%s'",
   "%s declaration follows executable statement",
   "Outer codeblock variable '%s' is out of reach",
   "Invalid numeric format '.'",
   "Unterminated string '%s'",
   "Redefinition of predefined function %s as '%s'",
   "Illegal variable '%s' initializer '%s'",
   "ENDIF does not match IF",
   "ENDDO does not match WHILE",
   "ENDCASE does not match DO CASE",
   "NEXT does not match FOR",
   "ELSE does not match IF",
   "ELSEIF does not match IF",
   "Syntax error '%s'",
   "Unclosed control structure '%s'",
   "%s statement with no loop in sight",
   "Syntax error '%s' in '%s'",
   "Incomplete statement or unbalanced delimiters",
   "Incorrect number of arguments in %s %s",   // E0021

   ...
}




HB_FUNC( ROUND )
{
   PHB_ITEM pNumber = hb_param( 1, HB_IT_NUMERIC );

   if( pNumber && HB_IS_PARAM_NUM( 2 ) )
   {
      int iDec = hb_parni( 2 );

      if( iDec == 0 && HB_IS_NUMINT( pNumber ) )
         hb_retnint( hb_itemGetNInt( pNumber ) );
      else
         hb_retnlen( hb_numRound( hb_itemGetND( pNumber ), iDec ), 0, HB_MAX( iDec, 0 ) );
   }
   else
      hb_errRT_BASE_SubstR( EG_ARG, 1094, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS );
}



HB_FUNC( __ERRRT_SBASE )
{
   hb_errRT_BASE_SubstR( ( HB_ERRCODE ) hb_parni( 1 ),
                         ( HB_ERRCODE ) hb_parni( 2 ),
                         hb_parc( 3 ),
                         hb_parc( 4 ),
                         ( hb_pcount() > 5 && hb_parnl( 5 ) > 0 ? 1 : 0 ),
                         hb_param( 6, HB_IT_ANY ) );
}


void hb_errRT_BASE_SubstR( HB_ERRCODE errGenCode, HB_ERRCODE errSubCode, const char * szDescription, const char * szOperation, HB_ULONG ulArgCount, ... )
{
   PHB_ITEM pError;

   PHB_ITEM pArray;
   va_list va;
   HB_ULONG ulArgPos;

   pError = hb_errRT_New_Subst( ES_ERROR, HB_ERR_SS_BASE, errGenCode, errSubCode, szDescription, szOperation, 0, EF_NONE );

   /* Build the array from the passed arguments. */
   switch( ulArgCount )
   {
      case 0:
         pArray = NULL;
         break;

      case HB_ERR_ARGS_BASEPARAMS:
         pArray = hb_pcount() ? hb_arrayBaseParams() : NULL;
         break;

      case HB_ERR_ARGS_SELFPARAMS:
         pArray = hb_arraySelfParams();
         break;

      default:
         pArray = hb_itemArrayNew( ulArgCount );

         va_start( va, ulArgCount );
         for( ulArgPos = 1; ulArgPos <= ulArgCount; ulArgPos++ )
         {
            PHB_ITEM pArg = va_arg( va, PHB_ITEM );
            if( pArg )
               hb_itemArrayPut( pArray, ulArgPos, pArg );
         }
         va_end( va );
   }

   if( pArray )
   {
      /* Assign the new array to the object data item. */
      hb_errPutArgsArray( pError, pArray );

      /* Release the Array. */
      hb_itemRelease( pArray );
   }

   /* Ok, launch... */
   hb_itemReturnRelease( hb_errLaunchSubst( pError ) );
   hb_errRelease( pError );
}



OUT - clipper compatibility
===========================

HB_COMPAT_C53 - always on
HB_CLP_STRICT - always off
HB_CLP_UNDOC - always on


HB_ISNUM => HB_IS_PARAM_NUM